import asyncio
import io
import threading
from typing import Callable

from py_astealth.generated.async_interface import AsyncInterface
from py_astealth.generated.sync_interface import SyncInterface
from py_astealth.stealth_api import StealthApi
from py_astealth.stealth_client import AsyncStealthClient
from py_astealth.core.base_types import RPCType
from py_astealth.core.api_specification import MethodSpec, ApiSpecification, implement_api


def create_async_method(method_spec: MethodSpec) -> Callable:
    """
    async method implementation
    """
    async def api_method_impl(self: AsyncStealthClient, *args, **kwargs):
        # 'self' is an instance of AsyncStealthApiClient, which inherits from AsyncStealthClient.
        # It just passes the call down to 'call_method'.
        return await self.call_method(method_spec, *args)

    # for better debugging
    api_method_impl.__name__ = method_spec.name
    api_method_impl.__doc__ = f"Async API method for {method_spec.name}(...)"
    return api_method_impl


@implement_api(StealthApi, method_factory=create_async_method)
class AsyncStealthApiClient(AsyncInterface, AsyncStealthClient):
    """
    Stealth asynchronous client. All API methods from StealthApi are generated by a decorator,
    using the create_async_proxy_method factory
    """
    def __init__(self, host: str, port: int):
        super().__init__(host, port)


class SyncApiAdapter:
    """
    A synchronous adapter for an asynchronous client.
    Manages the asyncio event loop on a background thread.
    """
    def __init__(self, async_client_class, host: str, port: int):
        self._async_client = async_client_class(host, port)
        self._loop = None
        self._thread = None
        self._ready_event = threading.Event()

    def __enter__(self):
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def _run_event_loop(self):
        try:
            self._loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self._loop)
            self._loop.run_until_complete(self._async_client.connect())
            self._ready_event.set()
            self._loop.run_forever()
        finally:
            self._loop.close()

    def connect(self):
        if self._thread is not None:
            raise RuntimeError("Already connected")
        self._thread = threading.Thread(target=self._run_event_loop, daemon=True)
        self._thread.start()
        if not self._ready_event.wait(timeout=10):
            raise ConnectionError("Cannot connect")

    def close(self):
        if self._thread is None or self._loop is None or not self._loop.is_running():
            return
        self._loop.call_soon_threadsafe(self._async_client.close)
        self._loop.call_soon_threadsafe(self._loop.stop)
        self._thread.join()
        self._thread = None
        self._loop = None
        self._ready_event.clear()


def create_sync_proxy_method(method_spec: MethodSpec) -> Callable:
    """
    sync method implementation
    """
    def sync_proxy_impl(self: SyncApiAdapter, *args, **kwargs):
        if self._loop is None or not self._loop.is_running():
            raise ConnectionError("Client not connected")

        # get an asynchronous method from the '_async_client'
        async_method = getattr(self._async_client, method_spec.name)

        # we create a coroutine method with arguments and pass it for execution
        coro = async_method(*args, **kwargs)
        future = asyncio.run_coroutine_threadsafe(coro, self._loop)
        try:
            return future.result(timeout=30)
        except Exception as e:
            raise e

    sync_proxy_impl.__name__ = method_spec.name
    sync_proxy_impl.__doc__ = f"Sync proxy for API method {method_spec.name}(...)"
    return sync_proxy_impl


@implement_api(StealthApi, method_factory=create_sync_proxy_method)
class SyncStealthApiClient(SyncInterface, SyncApiAdapter):
    """
    Stealth synchronous client. All API methods are generated by a decorator,
    using the create_sync_proxy_method factory, which creates a proxy
    for AsyncStealthApiClient methods.
    """
    def __init__(self, host: str, port: int):
        super().__init__(async_client_class=AsyncStealthApiClient, host=host, port=port)
