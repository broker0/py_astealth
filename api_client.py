import asyncio
import threading
from typing import Callable, Optional, Any, Coroutine

from py_astealth.generated.async_interface import AsyncInterface
from py_astealth.generated.sync_interface import SyncInterface
from py_astealth.stealth_api import StealthApi
from py_astealth.stealth_client import AsyncStealthClient, StealthEvent
from py_astealth.core.api_specification import MethodSpec, implement_api


def create_async_method(method_spec: MethodSpec) -> Callable:
    """
    async method implementation
    """
    async def api_method_impl(self: AsyncStealthClient, *args, **kwargs):
        # 'self' is an instance of AsyncStealthApiClient, which inherits from AsyncStealthClient.
        # It just passes the call down to 'call_method'.
        return await self.call_method(method_spec, *args)

    # for better debugging
    api_method_impl.__name__ = method_spec.name
    api_method_impl.__doc__ = f"Async API method for {method_spec.name}(...)"
    return api_method_impl


@implement_api(StealthApi, method_factory=create_async_method)
class AsyncStealthApiClient(AsyncInterface, AsyncStealthClient):
    """
    Stealth asynchronous client. All API methods from StealthApi are generated by a decorator,
    using the create_async_proxy_method factory
    """
    def __init__(self, host: str = None, port: int = None):
        super().__init__(host, port)

    async def get_event(self):
        """
        return the next event from the queue or None if there are no events
        """
        try:
            return self.events.get_nowait()
        except asyncio.QueueEmpty:
            return None


def create_sync_proxy_method(method_spec: MethodSpec) -> Callable:
    """
    sync method implementation factory
    """

    def sync_proxy_impl(self, *args, **kwargs):
        # get an asynchronous method from the '_async_client'
        async_method = getattr(self._async_client, method_spec.name)
        # we create a coroutine method with arguments
        coro = async_method(*args, **kwargs)

        if self._threaded:
            if self._loop is None or not self._loop.is_running():
                raise ConnectionError("Client not connected")

            future = asyncio.run_coroutine_threadsafe(coro, self._loop)
            try:
                return future.result(timeout=30)
            except Exception as e:
                raise e
        else:
            if self._loop is None:  # or self._loop.is_running(): # is_running check might be tricky if we are inside the loop? No, we are sync.
                raise ConnectionError("Client not connected")
            return self._loop.run_until_complete(coro)

    sync_proxy_impl.__name__ = method_spec.name
    sync_proxy_impl.__doc__ = f"Sync proxy for API method {method_spec.name}(...)"
    return sync_proxy_impl


@implement_api(StealthApi, method_factory=create_sync_proxy_method)
class SyncStealthApiClient(SyncInterface):
    """
    Stealth synchronous client.
    Can operate in two modes:
    1. Threaded (threaded=True): Runs the asyncio loop in a background thread. Thread-safe.
    2. Non-threaded (threaded=False): Runs the asyncio loop in the current thread. Not thread-safe.
    """
    def __init__(self, host: str = None, port: int = None, threaded: bool = True):
        self._async_client = AsyncStealthApiClient(host, port)
        self._threaded = threaded
        self._lock = threading.Lock()
        self._loop = None
        self._thread = None
        self._ready_event = threading.Event()

    def __enter__(self):
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def connect(self):
        if self._threaded:
            with self._lock:
                if self._thread is not None:
                    raise RuntimeError("Already connected")
                self._thread = threading.Thread(target=self._run_event_loop, daemon=True)
                self._thread.start()
                if not self._ready_event.wait(timeout=10):
                    raise ConnectionError("Cannot connect")
        else:
            if self._loop is not None:
                 raise RuntimeError("Already connected")
            self._loop = asyncio.new_event_loop()
            self._loop.run_until_complete(self._async_client.connect())

    def close(self):
        if self._threaded:
            with self._lock:
                if self._thread is None or self._loop is None or not self._loop.is_running():
                    return
                self._loop.call_soon_threadsafe(self._async_client.close)
                self._loop.call_soon_threadsafe(self._loop.stop)
                self._thread.join()
                self._thread = None
                self._loop = None
                self._ready_event.clear()
        else:
            if self._loop is None:
                return
            if not self._loop.is_closed():
                self._async_client.close()
                self._loop.close()
            self._loop = None

    def get_event(self) -> Optional[StealthEvent]:
        coro = self._async_client.get_event()
        if self._threaded:
             return self._execute_coro_in_loop(coro, timeout=1.0)
        else:
             return self._loop.run_until_complete(coro)

    def _run_event_loop(self):
        try:
            self._loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self._loop)
            self._loop.run_until_complete(self._async_client.connect())
            self._ready_event.set()
            self._loop.run_forever()
        finally:
            self._loop.close()

    def _execute_coro_in_loop(self, coro: Coroutine, timeout: Optional[float]) -> Any:
        if self._loop is None or not self._loop.is_running():
            raise ConnectionError("Client not connected")

        future = asyncio.run_coroutine_threadsafe(coro, self._loop)

        try:
            return future.result(timeout=timeout)
        except (asyncio.TimeoutError, TimeoutError):
            return None
        except Exception as e:
            raise e
