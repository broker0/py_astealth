import asyncio
import io
import threading
from typing import Callable

from py_astealth.generated.async_interface import AsyncInterface
from py_astealth.generated.sync_interface import SyncInterface
from py_astealth.stealth_api import StealthApi
from py_astealth.stealth_client import AsyncStealthClient
from py_astealth.core.base_types import RPCType
from py_astealth.core.api_specification import MethodSpec, ApiSpecification, implement_api


def create_async_method(method_spec: MethodSpec) -> Callable:
    """
    async method implementation
    """
    async def api_method_impl(self: AsyncStealthClient, *args, **kwargs):
        # This is a function and is an implementation of an API method.
        # 'self' is assumed to inherit from AsyncRPCClient.
        if len(args) != len(method_spec.args):
            raise TypeError(f"{method_spec.name}() takes {len(method_spec.args)} arguments but {len(args)} were given")

        # Serialization of arguments
        with io.BytesIO() as args_stream:
            arg_types = [arg.type for arg in method_spec.args]
            for arg_value, arg_type in zip(args, arg_types):
                RPCType.pack_value(args_stream, arg_value, arg_type)
            args_payload = args_stream.getvalue()

        # Calling an RPC method through an instance of self
        ret_type = method_spec.result.type
        call_ret_arg = None if ret_type is type(None) else ret_type

        # use 'self.call_method', which will be available on the instance
        # by passing it the method number, serialized arguments, and the return type class.
        result_payload = await self.call_method(method_spec.id, args_payload, call_ret_arg)

        # no ret value
        if call_ret_arg is None or not result_payload:
            return None

        # Deserialization of the result
        result_stream = io.BytesIO(result_payload)
        return RPCType.unpack_value(result_stream, ret_type)

    # for better debugging
    api_method_impl.__name__ = method_spec.name
    api_method_impl.__doc__ = f"Async API method for {method_spec.name}(...)"
    return api_method_impl


@implement_api(StealthApi, method_factory=create_async_method)
class AsyncStealthApiClient(AsyncInterface, AsyncStealthClient):
    """
    Stealth asynchronous client. All API methods from StealthApi are generated by a decorator,
    using the create_async_proxy_method factory
    """
    def __init__(self, host: str, port: int):
        super().__init__(host, port)


class SyncApiAdapter:
    """
    A synchronous adapter for an asynchronous client.
    Manages the asyncio event loop on a background thread.
    """
    def __init__(self, async_client_class, host: str, port: int):
        self._async_client = async_client_class(host, port)
        self._loop = None
        self._thread = None
        self._ready_event = threading.Event()

    def __enter__(self):
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def _run_event_loop(self):
        try:
            self._loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self._loop)
            self._loop.run_until_complete(self._async_client.connect())
            self._ready_event.set()
            self._loop.run_forever()
        finally:
            self._loop.close()

    def connect(self):
        if self._thread is not None:
            raise RuntimeError("Already connected")
        self._thread = threading.Thread(target=self._run_event_loop, daemon=True)
        self._thread.start()
        if not self._ready_event.wait(timeout=10):
            raise ConnectionError("Cannot connect")

    def close(self):
        if self._thread is None or self._loop is None or not self._loop.is_running():
            return
        self._loop.call_soon_threadsafe(self._async_client.close)
        self._loop.call_soon_threadsafe(self._loop.stop)
        self._thread.join()
        self._thread = None
        self._loop = None
        self._ready_event.clear()


def create_sync_proxy_method(method_spec: MethodSpec) -> Callable:
    """
    sync method implementation
    """
    method_name = method_spec.name

    def sync_proxy_impl(self: SyncApiAdapter, *args, **kwargs):
        if self._loop is None or not self._loop.is_running():
            raise ConnectionError("Client not connected")

        # get an asynchronous method from the '_async_client'
        async_method = getattr(self._async_client, method_name)

        # we create a coroutine method with arguments and pass it for execution
        coro = async_method(*args, **kwargs)
        future = asyncio.run_coroutine_threadsafe(coro, self._loop)
        try:
            return future.result(timeout=30)
        except Exception as e:
            raise e

    sync_proxy_impl.__name__ = method_name
    sync_proxy_impl.__doc__ = f"Sync proxy for API method {method_name}(...)"
    return sync_proxy_impl


@implement_api(StealthApi, method_factory=create_sync_proxy_method)
class SyncStealthApiClient(SyncInterface, SyncApiAdapter):
    """
    Stealth synchronous client. All API methods are generated by a decorator,
    using the create_sync_proxy_method factory, which creates a proxy
    for AsyncStealthApiClient methods.
    """
    def __init__(self, host: str, port: int):
        super().__init__(async_client_class=AsyncStealthApiClient, host=host, port=port)
